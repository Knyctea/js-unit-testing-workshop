describe('The LoadMore module', function () {
  var spec;

  it('does stuff', function () {
    expect(spec).toBeUndefined();
  });
});
describe('The LoadMore module', function () {
  var loader;

  // DOM fixture
  var dest = document.createElement('div');
  dest.className = 'content-list';

  var trigger = document.createElement('a');
  trigger.href = 'http://www.example.com/foo?page=2';
  trigger.className = 'trigger';

  var container = document.createElement('div');
  container.appendChild(dest);
  container.appendChild(trigger);

  // mock events
  var triggerClickEvent = { target: trigger };
  var destinationClickEvent = { target: dest };

  // mock ajax response
  var response = {
    contentType: 'text/html',
    responseText: '<div class="ajax-content">foo</div>'
  };

  beforeEach(function () {
    // Ajax spy
    jasmine.Ajax.install();

    // create a clean instance of our object for each test.
    loader = new LoadMore(container, 'trigger', 'content-list');

    // spies
    // this doesn't work. the method has to be overridden at the source
    // spyOn(dest, 'addEventListener');
    // so we go to where its defines, the prototype of the Element object.
    spyOn(Element.prototype, 'addEventListener');
    spyOn(LoadMore.prototype, 'handleTriggerClick_');
    spyOn(LoadMore.prototype, 'handleLoadSuccess_')
    spyOn(LoadMore.prototype, 'handleLoadFailure_')
    spyOn(LoadMore.prototype, 'load').and.callThrough();
  });


  describe('The constructor, when called,', function () {
    it('needs a container element', function () {
      expect(function () { new LoadMore(container, 'foo', 'foo') }).not.toThrow();
      expect(function () { new LoadMore(undefined, 'foo', 'foo') }).toThrow();
    });

    it('needs a classname to identify the trigger', function () {
      expect(function () { new LoadMore(container, 'foo', 'foo') }).not.toThrow();
      expect(function () { new LoadMore(container, undefined, 'foo') }).toThrow();
      expect(function () { new LoadMore(container, '', 'foo') }).toThrow();
    });

    it('needs a classname to identify the destination', function () {
      expect(function () { new LoadMore(container, 'foo', 'foo') }).not.toThrow();
      expect(function () { new LoadMore(container, 'foo', undefined) }).toThrow();
      expect(function () { new LoadMore(container, 'foo', '') }).toThrow();
    });

    it('stores the arguments as private properties', function () {
      expect(loader.container_).toBe(container);
      expect(loader.triggerClassName_).toBe('trigger');
      expect(loader.destinationClassName_).toBe('content-list');
    });

    it('sets a listener for clicks on the trigger', function () {
      // we need to construct a new instance again because during out setup function the constructor is
      // called before the spies are added. So we should refactor to have the constructor called after the
      // spies.
      loader = new LoadMore(container, 'foo', 'foo');
      expect(dest.addEventListener).toHaveBeenCalled();
    });
  });


  describe('When called, the trigger click handler', function () {
    beforeEach(function () {
      LoadMore.prototype.handleTriggerClick_.and.callThrough();
    })

    it('needs an event to properly identify if the event was generated by the trigger', function () {
      expect(function () { loader.handleTriggerClick_(triggerClickEvent); }).not.toThrow();
      expect(function () { loader.handleTriggerClick_(undefined); }).toThrow();
    });

    it('will only call through if the event emanates from the trigger', function () {
      loader.handleTriggerClick_(triggerClickEvent);
      expect(loader.load.calls.count()).toBe(1);
      expect(loader.load).toHaveBeenCalledWith(trigger.href);

      loader.handleTriggerClick_(destinationClickEvent);
      // this doesn't work here, because the calls count in the spy doesn't reset here.
      // expect(loader.load).not.toHaveBeenCalled();
      expect(loader.load.calls.count()).toBe(1);
    });
  });

  describe('when called, the load method', function () {
    it('confirms the presence of a URL', function () {
      expect(loader.load).toThrow();
      expect(function() { loader.load('foo'); }).not.toThrow();
    });

    it('sends a request to the provided URL to get HTML', function () {
      loader.load(trigger.href);
      expect(jasmine.Ajax.requests.mostRecent().url).toBe(trigger.href);
    });

    it('passes successful responses to the success handler', function () {
      loader.load(trigger.href);
      jasmine.Ajax.requests.mostRecent().respondWith(jQuery.extend(response, {'status': 200}));
      expect(loader.handleLoadSuccess_).toHaveBeenCalled();
      expect(loader.handleLoadFailure_).not.toHaveBeenCalled();
    });

    it('passes unsuccessful responses to the failure handler', function () {
      loader.load(trigger.href);
      jasmine.Ajax.requests.mostRecent().respondWith(jQuery.extend(response, {'status': 404}));
      expect(loader.handleLoadFailure_).toHaveBeenCalled();
      expect(loader.handleLoadSuccess_).not.toHaveBeenCalled();
    });
  });

  it('when called the success handler injects the HTML string', function () {
    // remember to tell the spy to call through!! if you don't it won't and won't provide any feedback.
    loader.handleLoadSuccess_.and.callThrough();

    // test by checking the number of childre before and after the handler
    expect(dest.children.length).toBe(0);

    // test with an empty string
    loader.handleLoadSuccess_('');
    expect(dest.children.length).toBe(0);

    // test with a populated string
    loader.handleLoadSuccess_(response.responseText);
    expect(dest.children.length).toBe(1);
  });

  it('when called the failure handler throws an error', function () {
    loader.handleLoadFailure_.and.callThrough();
    expect(loader.handleLoadFailure_).toThrow();
  });
});
